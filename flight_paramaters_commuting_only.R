# Developed by Tom Evans at Lund University: tom.evans@biol.lu.se
# You are welcome to use parts of this code, but please give credit when using it extensively.
# Code available at https://github.com/thomasevans/lbbg_gps


# A script to analyse each flight, with various
# paramaters, such as maximum altitude, calculated.
# First the database will be queried to pull out
# the data we need for our analysis.
# Second. Various paramaters and information about
# the flights will be calculated.
# Third. This will be ouput to a new database table
# specifically for flights.


# Database functions   ------
# To link to database
library(RODBC)

# Establish a connection to the database
gps.db <- odbcConnectAccess2007('D:/Documents/Work/GPS_DB/GPS_db.accdb')

# See what tables are available
# sqlTables(gps.db)


# Get commuting flights table
flights.com <- sqlQuery(gps.db, query=
                       "SELECT DISTINCT f.*
  FROM lund_flights_commuting AS f
  ORDER BY f.flight_id ASC;")






# Get a vector of flight numbers -----
# str(flights.com$flight_id)
flight_id <- sort(flights.com$flight_id)
f <- length(flight_id)


#Run function 'flight.info' in parallel########
# require(foreach)
# require(doParallel)

#use x cores, general solution for any windows machine.
# cl <- makeCluster(parallel::detectCores())     

#start the parellel session of R; the 'slaves', which will run the analysis.
# registerDoParallel(cl)   







#this maybe neccessary so that the clustered instances or R have the
#required vairables/ functions in their scope, i.e. those functions
#and vairables which are referred to within the 'foreach' function.
# clusterExport(cl, c("flight_id"))   

#NB see: http://stackoverflow.com/questions/9404881/writing-to-global-variables-in-using-dosnow-and-doing-parallelization-in-r
#There a solution is offered for exporting vairables from foreach to the global environment.

#make a list object to recieve the data
# lst <- list()

# x <- flight_id[1:10]
  source("flight_info.R")

lst <- lapply(flight_id,flight.info, type = "com")

# flight.info(flight_id[i], type = "com")
# warnings()


# flight.info(flights.com$flight_id[5], type = "com")
# i <- 1
#get paramaters for each flight
#Use system.time to time how long this takes.
<<<<<<< HEAD
# system.time({lst <- foreach(i = seq(along = flight_id )) %dopar%{
# #  system.time({lst <- foreach(i = c(1:10)) %dopar%{
# 
#   source("flight_info.R")
#   #calculate the trip numbers for the device i. i.e. the function 
#   #which we wish to run for each device.     
# 
# #   i <- 5000
# #   x <- flight.info(12435, type = "com")
# #   as.numeric(as.character(x[1]))
#   
#   x <- flight.info(flight_id[i], type = "com")
#   
#   
#   
#   
# #   ?any
#   
#   # Try some more times if it fails
#   if(any(is.na(x[1:10]))){
#     for (n in 1:5){
#       x <- flight.info(flight_id[i], type = "com")
#       if(x[1] != NA) break}
#   }
#   
# #   ?while
# #   flight.info(flight_id[5000], type = "com")
#   x <- t(x)
# 
#   #output data as list (this will be appended to the global list, lst.
#   list(x)   
# } #end of foreach functions
# }) #end of things being timed by system.time
# 
# #close cluster
# stopCluster(cl)
=======
system.time({lst <- foreach(i = seq(along = flight_id )) %dopar%{
#  system.time({lst <- foreach(i = c(1:10)) %dopar%{

  source("flight_info.R")
  #calculate the trip numbers for the device i. i.e. the function 
  #which we wish to run for each device.     

  x <- flight.info(flight_id[i], type = "com")
#   flight.info(flight_id[5000], type = "com")
  x <- t(x)

  #output data as list (this will be appended to the global list, lst.
  list(x)   
} #end of foreach functions
}) #end of things being timed by system.time

#close cluster
stopCluster(cl)
>>>>>>> f98353f21f760af9064c3f5c800dbb825d85a851
#Time taken one time 4006.31 s (67 mins), 3105s another time
#Time taken on 20130929 (now including data from 2011, 2012, 2013): 7425 seconds (124 minutes).
 


#Create dataframe of flights########
#names for the dataframe
names.flights <- c("flight_id",
                   "points", "start_time",
                   "end_time", "duration",
                   "dist_max", "dist_total",
                   "interval_mean", "interval_min",
                   "device_info_serial",
                   "start_long", "start_lat",
                   "end_long", "end_lat",
                   "dist_nest_start",
                   "dist_nest_end",
                   "dist_nest_dif", "dist_a_b",
                   "straigtness", "bearing_a_b",
                   "speed_a_b", "speed_inst_mean",
                   "speed_inst_med",
                   "speed_inst_var", "alt_max",
                   "alt_min", "alt_mean", "alt_med",
                   "rho", "ang_dev", "ang_var")

#make a dataframe from the list generated by the above function.
flights <- data.frame(matrix(unlist(lst), nrow = length(flight_id), byrow = T))
# data.frame(matrix(unlist(lst), nrow = 3, byrow = T))

row.names(flights) <- NULL

names(flights) <- names.flights

# test <- flights[order(as.numeric(flights$flight_id)),]
# summary(sort(as.numeric(flights$flight_id)) == sort(flight_id))
# 
# sort(as.numeric(flights$flight_id))[1:100]
# str(as.numeric(flights$flight_id))
# sort(sort(flight_id))[1:100]
# str(flight_id)
# # row.names(test) <- NULL
# summary(is.na(flights))
# summary(is.na(test$flight_id))
# flight_id[1:100]
# summary(as.numeric(flights.com$flight_id) == flight_id)
# str(flights)

#origin of UNIX date_time, required for coversion back to datetime objects for start_time and end_time
startdate <- "1970-01-01"
startdate <- as.Date(startdate)

#convert the end_time back to datetime format
flights$end_time <- as.POSIXct(
  as.POSIXlt(flights$end_time, origin=startdate,
             tz= "GMT",format="%Y-%m-%d %H:%M:%S"))

#conver the start_time back to datetime format
flights$start_time <- as.POSIXct(
  as.POSIXlt(flights$start_time, origin=startdate,
             tz= "GMT",format="%Y-%m-%d %H:%M:%S"))

# save(flights, file = "flights_part1.Rdata")


fx <- function(x){
  x <- as.character(x)
  as.numeric(x)
}

flights2 <- cbind(sapply(flights[,c(1,2)], fx), flights[,c(3,4)],sapply(flights[,5:31], fx))

# str(flights3)

flights3 <- flights2[!is.na(flights2$flight_id),]




#output data to database##################

#export flight information to the database
#will be neccessary to edit table in Access after to define data-types and primary keys and provide descriptions for each variable.
sqlSave(
  gps.db, flights3, tablename = "lund_flights_commuting_par",
  append = FALSE, rownames = FALSE,
  colnames = FALSE, verbose = FALSE,
  safer = TRUE, addPK = FALSE,
  fast = TRUE, test = FALSE,
  nastring = NULL,
  varTypes = c(start_time = "Date", end_time= "Date"))
  
message("After exporting table to DB, edit table in Access to define data-types and primary keys")


# x <- as.vector(as.matrix(flights))
# summary(x == "Error")

# idx <- c(1:length(flight_id))
# idx.n <- idx[is.na(flights2$flight_id)]
# flights2.n <- flights2[idx.n,]
