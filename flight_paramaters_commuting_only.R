# Developed by Tom Evans at Lund University: tom.evans@biol.lu.se
# You are welcome to use parts of this code, but please give credit when using it extensively.
# Code available at https://github.com/thomasevans/lbbg_gps


# A script to analyse each flight, with various
# paramaters, such as maximum altitude, calculated.
# First the database will be queried to pull out
# the data we need for our analysis.
# Second. Various paramaters and information about
# the flights will be calculated.
# Third. This will be ouput to a new database table
# specifically for flights.


# Database functions   ------
# To link to database
library(RODBC)

# Establish a connection to the database
gps.db <- odbcConnectAccess2007('D:/Documents/Work/GPS_DB/GPS_db.accdb')

# See what tables are available
# sqlTables(gps.db)


# Get commuting flights table
flights.com <- sqlQuery(gps.db, query=
                       "SELECT DISTINCT f.*
  FROM lund_flights_commuting AS f
  ORDER BY f.flight_id ASC;")

# Close connection
odbcClose(gps.db)




# Get a vector of flight numbers -----
# str(flights.com$flight_id)
flight_id <- sort(flights.com$flight_id)
f <- length(flight_id)


#Run function 'flight.info' in parallel########
require(foreach)
require(doParallel)

#use x cores, general solution for any windows machine.
# cl <- makeCluster(parallel::detectCores())     
cl <- makeCluster(8)
#start the parellel session of R; the 'slaves', which will run the analysis.
registerDoParallel(cl)   

source("flight_info.R")
# warnings()
#this maybe neccessary so that the clustered instances or R have the
#required vairables/ functions in their scope, i.e. those functions
#and vairables which are referred to within the 'foreach' function.
clusterExport(cl, c("flight_id", "flight.info"))   
# ?clusterExport
# lst <- replicate(10, rep(NA, 31), simplify = FALSE)
# str(lst)
# vector("list", 10)
# rep(NA, 31)
lst <- list()
# ?list
# pb <- txtProgressBar(min = 0, max = f, style = 2)
# ?txtProgressBar
# system.time({lst <- foreach(i = seq(along = flight_id )) %dopar%{
# system.time({
#   for(i in seq(along = flight_id)){
#     for(i in c(1:10)){
      
system.time({
  lst <- foreach(i = c(1:10)) %dopar%{

  #   source("flight_info.R")
  #calculate the trip numbers for the device i. i.e. the function 
  #which we wish to run for each device.   
    
#   x <-  flight.info(12247, type = "com")
  # i <-  2
  x <- flight.info(flight_id[i], type = "com")
  
  # If it fails try again ten times, wait 2 s between each try then give up
   if(is.na(x[3])){
    count <- 0
    while((is.na(x[3])) & (count < 10)){
      source("flight_info.R")  # load function again
      # Not sure whey there's an error, but probably some how related to database access,     
      # waiting some time may help with this
      Sys.sleep(2)
      x <- flight.info(as.character(flight_id[i]), type = "com")
      count <- count + 1
    }  
  }
      
  x <- t(x)

  #output data as list (this will be appended to the global list, lst.
  return(x)   
#   lst[[i]] <- x
} #end of foreach functions
}) #end of things being timed by system.time
# str(lst)
# warnings()

#close cluster
stopCluster(cl)
#Time taken one time  ca. 450 s (< 10 minutes)
str(lst)


#Create dataframe of flights  ------
#names for the dataframe
names.flights <- c("flight_id",
                   "points", "start_time",
                   "end_time", "duration",
                   "dist_max", "dist_total",
                   "interval_mean", "interval_min",
                   "device_info_serial",
                   "start_long", "start_lat",
                   "end_long", "end_lat",
                   "dist_nest_start",
                   "dist_nest_end",
                   "dist_nest_dif", "dist_a_b",
                   "straigtness", "bearing_a_b",
                   "speed_a_b", "speed_inst_mean",
                   "speed_inst_med",
                   "speed_inst_var", "alt_max",
                   "alt_min", "alt_mean", "alt_med",
                   "rho", "ang_dev", "ang_var")

#make a dataframe from the list generated by the above function.
flights <- data.frame(matrix(unlist(lst), nrow = f, byrow = TRUE))
# flights <- data.frame(matrix(unlist(lst), nrow = 10, byrow = TRUE))

row.names(flights) <- NULL

names(flights) <- names.flights

#origin of UNIX date_time epoch, required for coversion back to datetime objects for start_time and end_time
startdate <- "1970-01-01"
startdate <- as.Date(startdate)

#convert the end_time back to datetime format
flights$end_time <- as.POSIXct(
  as.POSIXlt(flights$end_time, origin=startdate,
             tz= "GMT",format="%Y-%m-%d %H:%M:%S"))

#conver the start_time back to datetime format
flights$start_time <- as.POSIXct(
  as.POSIXlt(flights$start_time, origin=startdate,
             tz= "GMT",format="%Y-%m-%d %H:%M:%S"))

# save(flights, file = "flights_part1.Rdata")


fx <- function(x){
  x <- as.character(x)
  as.numeric(x)
}

flights2 <- cbind(sapply(flights[,c(1,2)], fx), flights[,c(3,4)],sapply(flights[,5:31], fx))


#output data to database##################

#export flight information to the database
#will be neccessary to edit table in Access after to define data-types and primary keys and provide descriptions for each variable.
sqlSave(
  gps.db, flights2, tablename = "lund_flights_commuting_par",
  append = FALSE, rownames = FALSE,
  colnames = FALSE, verbose = FALSE,
  safer = TRUE, addPK = FALSE,
  fast = TRUE, test = FALSE,
  nastring = NULL,
  varTypes = c(start_time = "Date", end_time= "Date"))
  
message("After exporting table to DB, edit table in Access to define data-types and primary keys")

odbcCloseAll()

# 
# fails_1 <- fails
#   save(fails_1, file = "fails1.RData")

