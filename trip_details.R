#********************************
#This script extracts data from the database, then for each trip, produces a summary, for example, greatest distance and bearing at that point, trip duration, start time, end time, number of points, gps interval


#To link to database
library(RODBC)

#Establish a connection to the database
gps.db <- odbcConnectAccess2007('F:/Documents/Work/GPS_DB/GPS_db.accdb')

#See what tables are available
sqlTables(gps.db)

#for all of data_base, except pre-deployment and null records
gps <- sqlQuery(gps.db, query="SELECT DISTINCT c.*, g.longitude, g.latitude, g.altitude
  FROM gps_uva_tracking_limited AS g, cal_mov_paramaters AS c
  WHERE g.device_info_serial = c.device_info_serial
    AND g.date_time = c.date_time
    ORDER BY c.device_info_serial ASC, c.date_time ASC ;"
                ,as.is=TRUE)

#for testing purposes we only take the first x lines
#gps <- gps[1:100000,]

#a hack/fix to make the date_time a POSIX object (i.e. R will now recognise this as a date-time object.
gps$date_time <- as.POSIXct(gps$date_time, tz="GMT",format="%Y-%m-%d %H:%M:%S")

#if we want to check which columns are present
names(gps)

#produce a vector of trip numbers
trip_id <- sort(unique(gps$trip_id))
f <- length(trip_id)
trip_id <- trip_id[2:f]   #remove zero (i.e. non trip points)

#get a list of available devices:
devices <- sort(unique(gps$device_info_serial))


#***********start of function: trip.info
#Function 'trip.info' produces a lists of lists of information on trips
#t - trip_id, the trip number
#gps - the gps dataframe
trip.info <- function(t, gps=gps){
 # t <- 2
  #make a subset of 'gps' containing just data for trip, t.
  sub01 <- subset(gps,trip_id == t)
#  names(gps)
  n <- length(sub01$date_time)         #the number of gps points for this trip
  start_time <- min(sub01$date_time)   #start time
  end_time  <-  max(sub01$date_time)  #end time
  duration <- as.numeric(difftime(end_time,start_time,units="secs"))   #get trip duration in seconds
  dist_max  <-  max(sub01$nest_gc_dist)   #greatest distance reached from nest

  dist_total <- sum(sub01$p2p_dist[2:n])   #total distance travelled, exclude first point p2p distance, as this includes distance to point before trip 'strated'.
  interval_mean <- mean(sub01$time_interval_s)   #mean log interval
  interval_min <- min(sub01$time_interval_s)     #min log interval, may be useful for highlighting trips where high resolution GPS data is available (i.e. where the conditional log mode was used). It might make more sense to floor or round this value.
  trip_type <- ifelse(min(sub01$latitude) < 50, 1, 0) #label trips, zero if non-migratory, and 1 if migratory.
  device_info_serial <- sub01$device_info_serial[1]  #get device_info_serial

  
  #make a vector containing all this data
  data.out <- c(t,device_info_serial,trip_type,n,start_time,end_time,duration,dist_max,dist_total,interval_mean,interval_min)  
  
  return(data.out)            #output a vector for the bird of trip id
}
#**********End of this function: trip.info


require(foreach)
require(doParallel)
cl <- makeCluster(parallel::detectCores())     #use x cores, general solution for any windows machine.
registerDoParallel(cl)   #start the parellel session of R; the 'slaves', which will run the analysis.
clusterExport(cl, c("gps","trip.info"))   #this maybe neccessary so that the clustered instances or R have the required vairables/ functions in their scope, i.e. those functions and vairables which are referred to within the 'foreach' function.

#NB see: http://stackoverflow.com/questions/9404881/writing-to-global-variables-in-using-dosnow-and-doing-parallelization-in-r
#There a solution is offered for exporting vairables from foreach to the global environment.
lst <- list()


#get paramaters for each trip
#Use system.time to time how long this takes - so far has taken around 10-15 minutes on 8 thread machine.
system.time({lst <- foreach(i = seq(along = trip_id )) %dopar%{
  #calculate the trip numbers for the device i. i.e. the function which we wish to run for each device.     
  x <- trip.info(trip_id[i],gps)
  x <- t(x)
  list(x)
  #list(x) #output x as list
} #end of foreach functions
}) #end of things being timed by system.time

#close cluster
stopCluster(cl)

#names for the dataframe
names.trips <- c("trip_id","device_info_serial","trip_type","fix_n","start_time","end_time","duration_s","dist_max","dist_total","interval_mean","interval_min")

#make a dataframe from the list generated by the above function.
trips <- data.frame(matrix(unlist(lst), nrow=length(trip_id), byrow=T))
names(trips) <- names.trips

#origin of UNIX date_time, required for coversion back to datetime objects for start_time and end_time
startdate <- "1970-01-01"
startdate <- as.Date(startdate)

#convert the end_time back to datetime format
trips$end_time <- as.POSIXct(as.POSIXlt(trips$end_time,origin=startdate, tz= "GMT",format="%Y-%m-%d %H:%M:%S"))

#conver the start_time back to datetime format
trips$start_time <- as.POSIXct(as.POSIXlt(trips$start_time,origin=startdate, tz= "GMT",format="%Y-%m-%d %H:%M:%S"))


#export trip information to the database
#will be neccessary to edit table in Access after to define data-types and primary keys
sqlSave(gps.db, trips, tablename = "lund_trips", append = FALSE,
        rownames = FALSE, colnames = FALSE, verbose = FALSE,
        safer = TRUE, addPK = FALSE,
        fast = TRUE, test = FALSE, nastring = NULL,varTypes=c(start_time="Date",end_time="Date"))